/**********************************************************************
 Copyright (c) 2020-2023, Unitree Robotics.Co.Ltd. All rights reserved.
 等待有缘人找到更好的估计方法！！！
***********************************************************************/

#ifndef EAFA5C89_D1C3_4526_9AD1_85E109ED4374
#define EAFA5C89_D1C3_4526_9AD1_85E109ED4374
#ifndef ESTIMATOR_H
#define ESTIMATOR_H

#include <vector>
#include "common/xingtianrobot.h"
#include "common/LowPassFilter.h"
#include "Gait/WaveGenerator.h"
#include "message/LowlevelState.h"
#include "string"

template <typename T>
class Estimator{
public:
    Estimator(QuadrupedRobot<T> *robotModel, LowlevelState<T>* lowState, VecInt4 *contact, Vec4<T> *phase, T dt);
    Estimator(QuadrupedRobot<T> *robotModel, LowlevelState<T>* lowState, VecInt4 *contact, Vec4<T> *phase, T dt, Vec18<T> Qdig, std::string testName);
    ~Estimator();
    Vec3<T>  getPosition();    //世界坐标下的位置
    Vec3<T>  getVelocity();    //世界坐标系下的速度
    Vec3<T>  getFootPos(int i);  //足端位置
    Vec34<T> getFeetPos();   
    Vec34<T> getFeetVel();       //足端速度
    Vec34<T> getPosFeet2BGlobal();   //世界坐标系下相对于机身的足端位置
    //添加接触相位估计
    VecInt4 getContactEstimator(){ return *_contact;}
    //添加返回姿态信息
    Quat<T> getQuat()const {return _lowState->imu.getQuat();}
    Vec3<T> getRPY(){return _lowState->imu.getRPY();}
    //返回角速度信息
    Vec3<T> getomega()const {return _lowState->imu.getGyro();}
    //返回机身旋转矩阵
    RotMat<T> getRotMat(){return _lowState->imu.getRotMat();}
    //返回世界坐标系下的加速度
    Vec3<T> getAccGlobal(){return _lowState->getAccGlobal();}
    //返回机身坐标系下的加速度

    Vec3<T> getAcc2B(){return _lowState->getAcc();}

    //返回机身坐标下的速度
    Vec3<T> getVelocity2B(){return getRotMat().transpose()*getVelocity();}
    
    void run();
    

private:
    void _initSystem();
    // Linear System
    Vec18<T>  _xhat;            // The state of estimator, position(3)+velocity(3)+feet position(3x4)
    Vec3<T> _u;                                        // The input of estimator
    Eigen::Matrix<T, 28,  1> _y;               // The measurement value of output y
    Eigen::Matrix<T, 28,  1> _yhat;            // The prediction of output y
    Eigen::Matrix<T, 18, 18> _A;               // The transtion matrix of estimator
    Eigen::Matrix<T, 18, 3>  _B;               // The input matrix
    Eigen::Matrix<T, 28, 18> _C;               // The output matrix
    // Covariance Matrix
    Eigen::Matrix<T, 18, 18> _P;               // Prediction covariance
    Eigen::Matrix<T, 18, 18> _Ppriori;         // Priori prediction covariance
    Eigen::Matrix<T, 18, 18> _Q;               // Dynamic simulation covariance
    Eigen::Matrix<T, 28, 28> _R;               // Measurement covariance
    Eigen::Matrix<T, 18, 18> _QInit;           // Initial value of Dynamic simulation covariance
    Eigen::Matrix<T, 28, 28> _RInit;           // Initial value of Measurement covariance
    Vec18<T> _Qdig;                                    // adjustable process noise covariance
    Mat3<T> _Cu;                                       // The covariance of system input u
    // Output Measurement
    Eigen::Matrix<T, 12, 1>  _feetPos2Body;    // The feet positions to body, in the global coordinate
    Eigen::Matrix<T, 12, 1>  _feetVel2Body;    // The feet velocity to body, in the global coordinate
    Eigen::Matrix<T,  4, 1>  _feetH;           // The Height of each foot, in the global coordinate
    Eigen::Matrix<T, 28, 28> _S;               // _S = C*P*C.T + R
    Eigen::PartialPivLU<Eigen::Matrix<T, 28, 28>> _Slu;    // _S.lu()
    Eigen::Matrix<T, 28,  1> _Sy;              // _Sy = _S.inv() * (y - yhat)
    Eigen::Matrix<T, 28, 18> _Sc;              // _Sc = _S.inv() * C
    Eigen::Matrix<T, 28, 28> _SR;              // _SR = _S.inv() * R
    Eigen::Matrix<T, 28, 18> _STC;             // _STC = (_S.transpose()).inv() * C
    Eigen::Matrix<T, 18, 18> _IKC;             // _IKC = I - KC

    RotMat<T> _rotMatB2G;                              // Rotate Matrix: from body to global
    Vec3<T> _g;
    Vec34<T> _feetPosGlobalKine, _feetVelGlobalKine;

    LowlevelState<T>* _lowState;
    QuadrupedRobot<T> *_robModel;
    Vec4<T> *_phase;
    VecInt4 *_contact;
    T _dt;
    T _trust;
    T _largeVariance;

    // Low pass filters
    LPFilter<T> *_vxFilter, *_vyFilter, *_vzFilter;

    // Tuning
    AvgCov<T> *_RCheck;
    AvgCov<T> *_uCheck;
    std::string _estName;

};

#endif  // ESTIMATOR_H


#endif /* EAFA5C89_D1C3_4526_9AD1_85E109ED4374 */
